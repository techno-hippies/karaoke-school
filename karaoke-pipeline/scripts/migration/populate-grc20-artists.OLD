/**
 * Populate grc20_artists table from multiple sources
 *
 * Data sources (in priority order):
 * 1. Quansic: 100% ISNI coverage for tracks with ISWCs (gold standard)
 * 2. MusicBrainz: 83% ISNI coverage, authoritative metadata
 * 3. Spotify: 95% coverage, popularity metrics
 * 4. Genius: 100% coverage (entry point), social media
 *
 * Strategy:
 * - Use ISNI as primary join key when available
 * - Flatten JSONB arrays to comma-separated TEXT
 * - Map all URL types from all_urls JSONB to individual columns
 */

import { query } from '../../src/db/neon';

interface ArtistAggregation {
  // Identity
  name: string;
  sortName?: string;
  alternateNames?: string;
  disambiguation?: string;

  // Industry IDs
  isni?: string;
  isniAll?: string;
  ipiAll?: string;
  mbid?: string;

  // Platform IDs
  spotifyArtistId?: string;
  geniusArtistId?: number;
  discogsId?: string;

  // Biographical
  artistType?: string;
  gender?: string;
  birthDate?: string;
  deathDate?: string;
  country?: string;

  // Musical
  genres?: string;

  // Popularity
  spotifyFollowers?: number;
  spotifyPopularity?: number;
  geniusFollowers?: number;
  isVerified?: boolean;

  // Social handles
  instagramHandle?: string;
  twitterHandle?: string;
  facebookHandle?: string;
  tiktokHandle?: string;
  youtubeChannel?: string;
  soundcloudHandle?: string;

  // URLs (will be extracted from MusicBrainz all_urls)
  urls: Record<string, string>;

  // Images
  imageUrl?: string;
  headerImageUrl?: string;
  imageSource?: string;
}

/**
 * Extract URL value from MusicBrainz all_urls JSONB
 */
function extractUrl(allUrls: any, pattern: string): string | undefined {
  if (!allUrls || typeof allUrls !== 'object') return undefined;

  // Find key that matches pattern (case-insensitive, partial match)
  const key = Object.keys(allUrls).find(k =>
    k.toLowerCase().includes(pattern.toLowerCase())
  );

  return key ? allUrls[key] : undefined;
}

/**
 * Extract primary handle from URL
 */
function extractHandle(url: string | undefined): string | undefined {
  if (!url) return undefined;

  // Extract last part of URL path
  const match = url.match(/\/([^\/\?]+)(?:\?|$)/);
  return match ? match[1].replace('@', '') : undefined;
}

async function main() {
  console.log('üéµ Populating grc20_artists table...\n');

  // Step 1: Get all unique artists from ACTUAL completed work (not pipeline status which is buggy)
  console.log('üìä Finding artists from processed tracks...');

  const processedArtists = await query(`
    SELECT DISTINCT
      st.artists->0->>'id' as spotify_artist_id,
      st.artists->0->>'name' as artist_name
    FROM karaoke_segments ks
    JOIN spotify_tracks st ON st.spotify_track_id = ks.spotify_track_id
    WHERE ks.fal_enhanced_grove_cid IS NOT NULL  -- Has completed audio
      AND st.artists->0->>'id' IS NOT NULL
    ORDER BY st.artists->0->>'name'
  `);

  console.log(`   Found ${processedArtists.length} unique artists from processed tracks\n`);

  // Step 2: Aggregate data for each artist
  const aggregations: ArtistAggregation[] = [];

  for (const { spotify_artist_id, artist_name } of processedArtists) {
    console.log(`üîç Aggregating: ${artist_name}`);

    const agg: ArtistAggregation = {
      name: artist_name,
      urls: {}
    };

    // Get Spotify data
    const spotifyData = await query(`
      SELECT * FROM spotify_artists WHERE spotify_artist_id = $1
    `, [spotify_artist_id]);

    if (spotifyData.length > 0) {
      const spotify = spotifyData[0];
      agg.spotifyArtistId = spotify.spotify_artist_id;
      agg.spotifyFollowers = spotify.followers;
      agg.spotifyPopularity = spotify.popularity;
      agg.imageUrl = spotify.image_url;
      agg.imageSource = 'spotify';

      if (spotify.genres && Array.isArray(spotify.genres)) {
        agg.genres = spotify.genres.join(', ');
      }
    }

    // Get Genius data
    const geniusData = await query(`
      SELECT ga.* FROM genius_artists ga
      JOIN genius_songs gs ON gs.genius_artist_id = ga.genius_artist_id
      JOIN spotify_tracks st ON st.spotify_track_id = gs.spotify_track_id
      WHERE st.artists->0->>'id' = $1
      LIMIT 1
    `, [spotify_artist_id]);

    if (geniusData.length > 0) {
      const genius = geniusData[0];
      agg.geniusArtistId = genius.genius_artist_id;
      agg.geniusFollowers = genius.followers_count;
      agg.isVerified = genius.is_verified;

      // Social media from Genius
      agg.instagramHandle = genius.instagram_handle;
      agg.twitterHandle = genius.twitter_handle;
      agg.facebookHandle = genius.facebook_handle;

      if (genius.image_url && !agg.imageUrl) {
        agg.imageUrl = genius.image_url;
        agg.imageSource = 'genius';
      }
    }

    // Get MusicBrainz data (authoritative + URLs)
    const mbData = await query(`
      SELECT * FROM musicbrainz_artists WHERE spotify_artist_id = $1
    `, [spotify_artist_id]);

    if (mbData.length > 0) {
      const mb = mbData[0];
      agg.mbid = mb.artist_mbid;
      // Note: sort_name, disambiguation, end_date not available in current schema
      agg.artistType = mb.artist_type;
      agg.gender = mb.gender;
      agg.birthDate = mb.birth_date;
      agg.country = mb.country;

      // Extract ISNIs
      if (mb.isnis && Array.isArray(mb.isnis) && mb.isnis.length > 0) {
        agg.isni = mb.isnis[0]; // Primary
        agg.isniAll = mb.isnis.join(', ');
      }

      // Extract IPIs
      if (mb.ipis && Array.isArray(mb.ipis) && mb.ipis.length > 0) {
        agg.ipiAll = mb.ipis.join(', ');
      }

      // Extract all URLs from all_urls JSONB
      if (mb.all_urls && typeof mb.all_urls === 'object') {
        const allUrls = mb.all_urls;

        // Social networks
        agg.urls.instagram_url = extractUrl(allUrls, 'instagram.com');
        agg.urls.twitter_url = extractUrl(allUrls, 'twitter.com');
        agg.urls.facebook_url = extractUrl(allUrls, 'facebook.com');
        agg.urls.tiktok_url = extractUrl(allUrls, 'tiktok.com');
        agg.urls.youtube_url = extractUrl(allUrls, 'youtube.com');
        agg.urls.soundcloud_url = extractUrl(allUrls, 'soundcloud.com');

        // Streaming
        agg.urls.spotify_url = extractUrl(allUrls, 'open.spotify.com');
        agg.urls.deezer_url = extractUrl(allUrls, 'deezer.com');
        agg.urls.tidal_url = extractUrl(allUrls, 'tidal.com');
        agg.urls.apple_music_url = extractUrl(allUrls, 'music.apple.com');

        // Databases
        agg.urls.wikidata_url = extractUrl(allUrls, 'wikidata.org');
        agg.urls.viaf_url = extractUrl(allUrls, 'viaf.org');
        agg.urls.imdb_url = extractUrl(allUrls, 'imdb.com');
        agg.urls.allmusic_url = extractUrl(allUrls, 'allmusic.com');
        agg.urls.discogs_url = extractUrl(allUrls, 'discogs.com');
        agg.urls.songkick_url = extractUrl(allUrls, 'songkick.com');

        // Lyrics
        agg.urls.genius_url = extractUrl(allUrls, 'genius.com');
        agg.urls.lastfm_url = extractUrl(allUrls, 'last.fm');

        // Official
        agg.urls.official_website = extractUrl(allUrls, 'official homepage');

        // Extract Discogs ID from URL
        const discogsUrl = agg.urls.discogs_url;
        if (discogsUrl) {
          const match = discogsUrl.match(/artist\/(\d+)/);
          if (match) agg.discogsId = match[1];
        }
      }
    }

    // Get Quansic data (ISNI gold standard)
    const quansicData = await query(`
      SELECT qr.* FROM quansic_recordings qr
      JOIN spotify_tracks st ON st.spotify_track_id = qr.spotify_track_id
      WHERE st.artists->0->>'id' = $1
      LIMIT 1
    `, [spotify_artist_id]);

    if (quansicData.length > 0 && quansicData[0].recording_data) {
      const recording = quansicData[0].recording_data;

      if (recording.artists && Array.isArray(recording.artists) && recording.artists.length > 0) {
        const artist = recording.artists[0];

        // Quansic ISNI overrides MusicBrainz (more reliable)
        if (artist.ids?.isnis && Array.isArray(artist.ids.isnis) && artist.ids.isnis.length > 0) {
          agg.isni = artist.ids.isnis[0];
          agg.isniAll = artist.ids.isnis.join(', ');
        }

        // Quansic IPIs
        if (artist.ids?.ipis && Array.isArray(artist.ids.ipis) && artist.ids.ipis.length > 0) {
          agg.ipiAll = artist.ids.ipis.join(', ');
        }
      }
    }

    aggregations.push(agg);
    console.log(`   ‚úÖ ${agg.name} (ISNI: ${agg.isni || 'none'})`);
  }

  console.log(`\nüìù Inserting ${aggregations.length} artists into grc20_artists...\n`);

  // Step 3: Insert into grc20_artists
  for (const agg of aggregations) {
    await query(`
      INSERT INTO grc20_artists (
        name, sort_name, alternate_names, disambiguation,
        isni, isni_all, ipi_all, mbid,
        spotify_artist_id, genius_artist_id, discogs_id,
        artist_type, gender, birth_date, death_date, country,
        genres,
        spotify_followers, spotify_popularity, genius_followers, is_verified,
        instagram_handle, twitter_handle, facebook_handle, tiktok_handle,
        youtube_channel, soundcloud_handle,
        instagram_url, twitter_url, facebook_url, tiktok_url,
        spotify_url, deezer_url, tidal_url, apple_music_url,
        soundcloud_url,
        wikidata_url, viaf_url, imdb_url, allmusic_url, discogs_url,
        songkick_url, genius_url, lastfm_url,
        youtube_url, official_website,
        image_url, header_image_url, image_source
      ) VALUES (
        $1, $2, $3, $4,
        $5, $6, $7, $8,
        $9, $10, $11,
        $12, $13, $14, $15, $16,
        $17,
        $18, $19, $20, $21,
        $22, $23, $24, $25,
        $26, $27,
        $28, $29, $30, $31,
        $32, $33, $34, $35,
        $36,
        $37, $38, $39, $40, $41,
        $42, $43, $44,
        $45, $46,
        $47, $48, $49
      )
      ON CONFLICT (spotify_artist_id) DO UPDATE SET
        updated_at = NOW()
    `, [
      agg.name, agg.sortName, agg.alternateNames, agg.disambiguation,
      agg.isni, agg.isniAll, agg.ipiAll, agg.mbid,
      agg.spotifyArtistId, agg.geniusArtistId, agg.discogsId,
      agg.artistType, agg.gender, agg.birthDate, agg.deathDate, agg.country,
      agg.genres,
      agg.spotifyFollowers, agg.spotifyPopularity, agg.geniusFollowers, agg.isVerified,
      agg.instagramHandle, agg.twitterHandle, agg.facebookHandle, agg.tiktokHandle,
      agg.youtubeChannel, agg.soundcloudHandle,
      agg.urls.instagram_url, agg.urls.twitter_url, agg.urls.facebook_url, agg.urls.tiktok_url,
      agg.urls.spotify_url, agg.urls.deezer_url, agg.urls.tidal_url, agg.urls.apple_music_url,
      agg.urls.soundcloud_url,
      agg.urls.wikidata_url, agg.urls.viaf_url, agg.urls.imdb_url, agg.urls.allmusic_url, agg.urls.discogs_url,
      agg.urls.songkick_url, agg.urls.genius_url, agg.urls.lastfm_url,
      agg.urls.youtube_url, agg.urls.official_website,
      agg.imageUrl, agg.headerImageUrl, agg.imageSource
    ]);

    console.log(`   ‚úÖ Inserted: ${agg.name}`);
  }

  // Step 4: Summary
  const summary = await query(`
    SELECT
      COUNT(*) as total,
      COUNT(isni) as with_isni,
      COUNT(grc20_entity_id) as minted,
      COUNT(*) - COUNT(grc20_entity_id) as ready_to_mint
    FROM grc20_artists
  `);

  console.log('\nüìä Summary:');
  console.log(`   Total artists: ${summary[0].total}`);
  console.log(`   With ISNI: ${summary[0].with_isni} (${Math.round(summary[0].with_isni / summary[0].total * 100)}%)`);
  console.log(`   Already minted: ${summary[0].minted}`);
  console.log(`   Ready to mint: ${summary[0].ready_to_mint}`);

  console.log('\n‚úÖ Done!\n');
}

main().catch(console.error);
