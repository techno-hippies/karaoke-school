/**
 * OpenRouter Service
 *
 * LLM API service for intelligent text matching
 * Primarily uses Gemini Flash 2.5 Lite for audio segment matching
 */

import { BaseService, ServiceConfig } from './base.js';

export interface OpenRouterMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

export interface OpenRouterResponse {
  choices: Array<{
    message: {
      content: string;
      role: string;
    };
  }>;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

export interface OpenRouterConfig extends ServiceConfig {
  model?: string;
  siteUrl?: string;
  appName?: string;
}

export class OpenRouterService extends BaseService {
  private model: string;
  private siteUrl: string;
  private appName: string;

  constructor(config: OpenRouterConfig = {}) {
    super('OpenRouter', {
      baseUrl: 'https://openrouter.ai/api/v1',
      ...config,
      apiKey: config.apiKey ?? process.env.OPENROUTER_API_KEY,
    });

    this.model = config.model || 'google/gemini-2.5-flash-lite-preview-09-2025';
    this.siteUrl = config.siteUrl || 'https://karaoke-school.ai';
    this.appName = config.appName || 'Karaoke School Audio Matcher';
  }

  /**
   * Send chat completion request to OpenRouter
   *
   * @param messages Array of chat messages
   * @param model Optional model override
   * @returns LLM response
   */
  async chat(
    messages: OpenRouterMessage[],
    model?: string
  ): Promise<OpenRouterResponse> {
    const apiKey = this.requireApiKey();

    const response = await fetch(`${this.config.baseUrl}/chat/completions`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': this.siteUrl,
        'X-Title': this.appName,
      },
      body: JSON.stringify({
        model: model || this.model,
        messages,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`OpenRouter API error: ${response.status} - ${errorText}`);
    }

    const result = await response.json();
    return result;
  }

  /**
   * Find matching segment in full song lyrics using Gemini Flash 2.5 Lite
   *
   * @param clipTranscript STT transcript from TikTok clip
   * @param fullWords Array of words with timestamps from forced alignment
   * @returns Start and end indices in fullWords array
   */
  async findSegmentMatch(
    clipTranscript: string,
    fullWords: Array<{ text: string; start: number; end: number }>
  ): Promise<{ startIdx: number; endIdx: number; reasoning?: string }> {
    this.log('Finding segment match with Gemini Flash 2.5 Lite...');

    // Format all words with indices and timestamps
    const allWords = fullWords
      .map(
        (w, i) => `${i}: "${w.text}" (${w.start.toFixed(2)}s - ${w.end.toFixed(2)}s)`
      )
      .join('\n');

    const prompt = `I have a TikTok clip transcript generated by STT (speech-to-text). This transcript may contain PHONETIC INACCURACIES - words that sound similar but are spelled wrong (e.g., "Tryna" instead of "Chyna", "bussy" instead of "pussy").

STT Transcript from clip:
"${clipTranscript}"

Below are ALL ${fullWords.length} words from the full song with their ACTUAL LYRICS and timestamps:

${allWords}

Your task: Find a SINGLE CONTIGUOUS SECTION of the song where the lyrics best match this STT transcript, accounting for:
- Phonetic errors (similar sounding words)
- Slang pronunciation
- Minor word variations (e.g., "gettin'" vs "get")
- Background vocals or ad-libs in parentheses

IMPORTANT:
- The match must be a CONTINUOUS sequence in the song, not scattered words from different parts
- Look for where most of the STT words appear together in order, even if some words are phonetically misspelled
- If multiple sections match equally well (e.g., repeated chorus), ALWAYS choose the EARLIEST occurrence (lowest start index)
- TikTok segments typically use the opening/intro of songs, so prefer matches closer to the beginning

Respond ONLY with:
START_INDEX: <number>
END_INDEX: <number>`;

    const response = await this.chat([
      {
        role: 'user',
        content: prompt,
      },
    ]);

    const answer = response.choices[0].message.content;

    this.log(`Gemini response:\n${answer}\n`);

    // Parse indices
    const startMatch = answer.match(/START_INDEX:\s*(\d+)/i);
    const endMatch = answer.match(/END_INDEX:\s*(\d+)/i);

    if (!startMatch || !endMatch) {
      throw new Error(`Could not parse indices from Gemini response: ${answer}`);
    }

    const startIdx = parseInt(startMatch[1]);
    const endIdx = parseInt(endMatch[1]);

    this.log(`Matched indices: ${startIdx} to ${endIdx}`);

    return {
      startIdx,
      endIdx,
      reasoning: answer,
    };
  }
}
